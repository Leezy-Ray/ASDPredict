// CC200 Atlas - 200 brain regions with MNI coordinates
// Coordinates are loaded from JSON file generated by Python script using nilearn

export interface BrainRegion {
  id: number;
  name: string;
  x: number;
  y: number;
  z: number;
  lobe: 'frontal' | 'parietal' | 'temporal' | 'occipital' | 'subcortical' | 'cerebellum';
  hemisphere: 'left' | 'right' | 'midline';
}

// Color mapping for brain lobes
export const LOBE_COLORS: Record<string, string> = {
  frontal: '#06b6d4',      // Cyan
  parietal: '#8b5cf6',     // Purple
  temporal: '#f59e0b',     // Amber
  occipital: '#10b981',    // Emerald
  subcortical: '#f472b6',  // Pink
  cerebellum: '#6366f1',   // Indigo
};

// Fallback data in case JSON file is not available
const FALLBACK_REGIONS: BrainRegion[] = [
  { id: 0, name: 'Region 0', x: 0, y: 0, z: 0, lobe: 'frontal', hemisphere: 'midline' },
];

// Load CC200 regions from JSON file
let CC200_REGIONS_CACHE: BrainRegion[] | null = null;

export async function loadCC200Regions(): Promise<BrainRegion[]> {
  if (CC200_REGIONS_CACHE) {
    return CC200_REGIONS_CACHE;
  }

  try {
        // #endregion
    
    const response = await fetch('/cc200_coordinates.json');
    
    if (!response.ok) {
      throw new Error(`Failed to load CC200 coordinates: ${response.statusText}`);
    }
    
    const data = await response.json();
    
        // #endregion
    
    // Validate and convert data
    const regions: BrainRegion[] = data.map((item: any) => ({
      id: item.id,
      name: item.name,
      x: item.x,
      y: item.y,
      z: item.z,
      lobe: item.lobe,
      hemisphere: item.hemisphere,
    }));
    
    CC200_REGIONS_CACHE = regions;
    return regions;
  } catch (error) {
    console.error('Error loading CC200 coordinates:', error);
        // #endregion
    
    // Return fallback data
    CC200_REGIONS_CACHE = FALLBACK_REGIONS;
    return FALLBACK_REGIONS;
  }
}

// Export a getter that returns the cached regions or loads them
export function getCC200Regions(): BrainRegion[] {
  if (CC200_REGIONS_CACHE) {
    return CC200_REGIONS_CACHE;
  }
  // If not loaded yet, return empty array (components should call loadCC200Regions first)
  return [];
}

// For backward compatibility, export CC200_REGIONS as a getter
// Components should use getCC200Regions() or ensure loadCC200Regions() is called first
export const CC200_REGIONS = new Proxy([] as BrainRegion[], {
  get(target, prop) {
    if (CC200_REGIONS_CACHE) {
      return (CC200_REGIONS_CACHE as any)[prop];
    }
    return (target as any)[prop];
  }
});

// Global coordinate mapping configuration - based on model actual size
export let coordinateMapping: {
  scale: number;
  offset: [number, number, number];
  modelBounds: { min: { x: number; y: number; z: number }; max: { x: number; y: number; z: number } };
  cc200Bounds: { min: { x: number; y: number; z: number }; max: { x: number; y: number; z: number } };
} | null = null;

// Export coordinate mapping function for use by other components
// Note: This function is now deprecated. Use getMappedPosition from BrainModel.tsx instead.
export function getMappedPosition(region: { x: number; y: number; z: number }): [number, number, number] {
  // Simple mapping without model dependency
  const MNI_SCALE = 0.01;
  return [
    region.x * MNI_SCALE,
    region.z * MNI_SCALE,
    -region.y * MNI_SCALE,
  ];
}
